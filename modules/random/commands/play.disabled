const axios = require('axios');

// REPLACE WITH YOUR STEAM API KEY
const STEAM_API_KEY = 'YOUR_STEAM_API_KEY_HERE';

module.exports = {
    name: 'play',
    description: 'Finds common multiplayer/co-op games between Steam profiles',
    syntax: 'play [steam_profile_url_1] [steam_profile_url_2] ...',
    num_args: 1,
    args_to_lower: false,
    needs_api: false,
    has_state: false,
    async execute(message, args, extra) {
        if (STEAM_API_KEY === 'YOUR_STEAM_API_KEY_HERE') {
            message.channel.send("Please configure the Steam API Key in the command file.");
            return;
        }

        const profileUrls = args;
        const steamIds = [];

        message.channel.send(`Analyzing ${profileUrls.length} profiles...`);

        // Helper to resolve Vanity URL to SteamID64
        const resolveSteamId = async (url) => {
            // Remove trailing slash
            url = url.replace(/\/$/, "");
            
            // Check for /profiles/ (already ID)
            const profilesMatch = url.match(/\/profiles\/(\d+)/);
            if (profilesMatch) return profilesMatch[1];

            // Check for /id/ (vanity)
            const idMatch = url.match(/\/id\/([^\/]+)/);
            if (idMatch) {
                const vanityName = idMatch[1];
                try {
                    const response = await axios.get(`http://api.steampowered.com/ISteamUser/ResolveVanityURL/v0001/?key=${STEAM_API_KEY}&vanityurl=${vanityName}`);
                    if (response.data.response.success === 1) {
                        return response.data.response.steamid;
                    }
                } catch (e) {
                    console.error(`Error resolving vanity URL ${vanityName}:`, e.message);
                }
            }
            return null;
        };

        // Resolve all IDs
        for (const url of profileUrls) {
            const id = await resolveSteamId(url);
            if (id) {
                steamIds.push(id);
            } else {
                message.channel.send(`Could not resolve Steam ID for URL: ${url}`);
            }
        }

        if (steamIds.length === 0) {
            message.channel.send("No valid Steam profiles found.");
            return;
        }

        // Fetch games for each ID
        const userGames = []; // Array of Sets of AppIDs
        const gameDetailsMap = new Map(); // AppID -> Game Name

        for (const id of steamIds) {
            try {
                const response = await axios.get(`http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key=${STEAM_API_KEY}&steamid=${id}&include_appinfo=1&format=json`);
                const games = response.data.response.games;
                if (!games) {
                    message.channel.send(`Could not retrieve games for Steam ID ${id}. Profile might be private.`);
                    return;
                }
                
                const gameIds = new Set();
                games.forEach(game => {
                    gameIds.add(game.appid);
                    gameDetailsMap.set(game.appid, game.name);
                });
                userGames.push(gameIds);
            } catch (e) {
                console.error(`Error fetching games for ${id}:`, e.message);
                message.channel.send(`Error fetching games for Steam ID ${id}.`);
                return;
            }
        }

        // Find intersection
        let commonGameIds = [...userGames[0]];
        for (let i = 1; i < userGames.length; i++) {
            commonGameIds = commonGameIds.filter(id => userGames[i].has(id));
        }

        if (commonGameIds.length === 0) {
            message.channel.send("No common games found.");
            return;
        }

        // Shuffle common games to get a random sample if we have too many
        for (let i = commonGameIds.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [commonGameIds[i], commonGameIds[j]] = [commonGameIds[j], commonGameIds[i]];
        }

        const maxCheck = 30;
        const gamesToCheck = commonGameIds.slice(0, maxCheck);
        
        message.channel.send(`Found ${commonGameIds.length} common games. Checking a sample of ${gamesToCheck.length} for Multiplayer/Co-op tags... (This will take about ${gamesToCheck.length * 1.5} seconds)`);

        const validGames = [];
        const targetCategories = [1, 9, 20, 36, 38];
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        let checkedCount = 0;
        for (const appId of gamesToCheck) {
            try {
                await delay(1500); 
                const storeResponse = await axios.get(`https://store.steampowered.com/api/appdetails?appids=${appId}`);
                const data = storeResponse.data[appId];

                if (data.success && data.data) {
                    const categories = data.data.categories || [];
                    const hasTargetCategory = categories.some(cat => targetCategories.includes(cat.id));
                    
                    if (hasTargetCategory) {
                        validGames.push({
                            name: data.data.name,
                            id: appId
                        });
                    }
                }
            } catch (e) {
                console.error(`Error checking store for app ${appId}:`, e.message);
            }
            checkedCount++;
        }

        if (validGames.length === 0) {
            message.channel.send(`Checked ${checkedCount} games, but found no Multiplayer/Co-op games.`);
            return;
        }

        const gameNames = validGames.map(g => g.name);
        const randomPick = validGames[Math.floor(Math.random() * validGames.length)];

        let output = `**Common Multiplayer/Co-op Games (Found ${validGames.length} in sample of ${checkedCount}):**\n`;
        output += gameNames.join('\n');
        output += `\n\n**I suggest you play:** ${randomPick.name}`;

        if (output.length > 2000) {
            const chunks = output.match(/[\s\S]{1,1900}/g) || [];
            for (const chunk of chunks) {
                await message.channel.send(chunk);
            }
        } else {
            message.channel.send(output);
        }
    }
}
